---
layout: blog
istop: false
title: "IO的类型比较"
background-image: ""
date: 2019-08-19
category: 笔记
tags: 阻塞 非阻塞 同步 异步 io 
---

### 阻塞IO与非阻塞IO的区别：

阻塞和非阻塞的区别在于，在没有数据到达时，是否返回。

阻塞：**在阻塞条件下，**如果没有发现数据在网络缓冲中会一直等待，当发现有数据的时候会把数据读到用户指定的缓冲区。

非阻塞：**在非阻塞的情况下，**read的行为是如果发现没有数据就直接返回，如果发现有数据那么也是采用有多少读多少的进行处理。

### 同步IO与异步IO的区别：

异步IO：调用aio_read，让内核等数据准备好，并且复制到用户进程空间后执行事先指定好的函数。

​	例如：E同学让舍管阿姨将杯子装满水后通知他。整个过程E同学都可以做别的事情(没有recv)，这才是真正的异步IO。

一般来讲：阻塞IO模型、非阻塞IO模型、IO复用模型(select/poll/epoll)、信号驱动IO模型都属于同步IO，因为阶段2是阻塞的(尽管时间很短)。。

### 信号驱动IO与异步IO的区别：

信号驱动IO：通过调用sigaction注册信号函数，等内核数据准备好的时候系统中断当前程序，执行信号函数(在这里面调用recv)。

​		打个比方：D同学让舍管阿姨等有水的时候通知他(注册信号函数)，没多久D同学得知有水了，跑去装水。是不是很像异步IO？很遗憾，它还是同步IO(省不了装水的时间啊)。

异步IO：用户进程发起aio_read（这是POSIX提供的异步IO函数,POSIX异步IO函数aio_或者lio_开头）操作之后、给内核传递描述符、缓冲区指针、缓冲区大小和read相同的三个参数以及文件偏移（与lseek类似）、告诉内核当整个操作完成时、如何通知我们、立刻就可以开始去做其它的事、而另一方面、从内核的角度、当它受到一个aio_read之后、首先它会立刻返回、所以不会对用户进程产生任何阻塞、然后、内核会等待数据准备完成、然后将数据拷贝到用户内存、当这一切都完成之后、内核会给用户进程发送一个信号、告诉它aio_read操作完成了